/**
 * Job Service
 * Business logic for deployment job operations
 */

const mongoose = require('mongoose');
const deploymentJobSchema = require('../schemas/deploymentJobSchema');
const deploymentProjectSchema = require('../schemas/deploymentProjectSchema');
const pipelineTemplateSchema = require('../schemas/pipelineTemplateSchema');

const DeploymentJob = mongoose.model('DeploymentJob', deploymentJobSchema);
const DeploymentProject = mongoose.model('DeploymentProject', deploymentProjectSchema);
const PipelineTemplate = mongoose.model('PipelineTemplate', pipelineTemplateSchema);

/**
 * List jobs with filters
 */
async function listJobs(filters, limit = 50, skip = 0) {
    const jobs = await DeploymentJob.find(filters)
        .sort({ createdAt: -1 })
        .limit(limit)
        .skip(skip)
        .lean();

    const total = await DeploymentJob.countDocuments(filters);

    return { jobs, total, limit, skip };
}

/**
 * Create a new deployment job
 */
async function createJob(jobData) {
    const jobId = `job_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
    const doc = new DeploymentJob({
        jobId,
        ...jobData,
        status: 'DISPATCHED',
        startedAt: new Date()
    });
    
    await doc.save();
    return { jobId, job: doc };
}

/**
 * Update job status
 */
async function updateJobStatus(jobId, status, finishedAt) {
    const update = {};
    if (status) update.status = status;
    if (finishedAt) update.finishedAt = new Date(finishedAt);
    
    await DeploymentJob.updateOne({ jobId }, { $set: update });
    return { success: true };
}

/**
 * Build payload for deployment based on project configuration
 */
async function buildDeploymentPayload(projectId, environment, type, version) {
    const project = await DeploymentProject.findById(projectId);
    if (!project) {
        throw new Error('Project not found');
    }

    const target = project.deploymentTargets.find(t => t.environment === environment);
    if (!target) {
        throw new Error(`No deployment target configured for environment: ${environment}`);
    }

    // Get pipeline template
    let pipeline = null;
    let buildCommands = [];
    let runCommands = [];
    let stopCommands = [];

    if (project.pipelineTemplateId) {
        pipeline = await PipelineTemplate.findById(project.pipelineTemplateId);
        if (pipeline) {
            buildCommands = pipeline.buildCommands || [];
            runCommands = pipeline.runCommands || [];
            stopCommands = pipeline.stopCommands || [];
        }
    }

    const agentId = target.agentId;
    let payload = {};

    // Build payload based on job type
    switch (type) {
        case 'deploy':
            payload = {
                repository: project.repoUrl,
                branch: project.branch || 'main',
                commands: buildCommands,
                artifacts: target.artifacts || [],
                deployPath: target.deployPath || '',
                repoPath: target.deployPath || '',
                envVars: project.envVars || [],
                autoStart: target.autoStart || false,
                startCommand: target.autoStart && runCommands.length > 0 ? runCommands.join(' && ') : '',
                version,
                project: project.name || 'project',
                environment: target.environment || 'default',
                // Docker configuration
                useDocker: pipeline?.useDocker || false,
                dockerImage: pipeline?.dockerImage,
                dockerfile: pipeline?.dockerfile,
                dockerBuildArgs: pipeline?.dockerBuildArgs || [],
                autoGenerateDockerfile: pipeline?.autoGenerateDockerfile || false,
                language: pipeline?.language,
                framework: pipeline?.framework,
                // Docker runtime options
                port: target.port,
                containerPort: target.containerPort || 3000,
                dockerVolumes: target.dockerVolumes || [],
                dockerEnvVars: target.dockerEnvVars || [],
                dockerNetwork: target.dockerNetwork || 'bridge',
            };
            break;

        case 'start':
        case 'stop':
        case 'restart':
            const containerName = `${(project.name || 'app').toLowerCase().replace(/[^a-z0-9-]/g, '-')}-${target.environment || 'default'}`;
            payload = {
                workDir: target.deployPath || '',
                useDocker: pipeline?.useDocker || false,
                project: project.name || 'project',
                environment: target.environment || 'default',
                containerName
            };

            if (type === 'start') {
                payload.startCommand = runCommands.length > 0 ? runCommands.join(' && ') : '';
            } else if (type === 'stop') {
                payload.stopCommand = stopCommands.length > 0 ? stopCommands.join(' && ') : '';
            } else if (type === 'restart') {
                payload.restartCommand = stopCommands.length > 0 && runCommands.length > 0
                    ? `${stopCommands.join(' && ')} && ${runCommands.join(' && ')}`
                    : '';
            }
            break;

        default:
            throw new Error(`Unknown job type: ${type}`);
    }

    return { agentId, payload, projectId };
}

module.exports = {
    listJobs,
    createJob,
    updateJobStatus,
    buildDeploymentPayload
};
